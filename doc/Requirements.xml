<!-- Maintainer: kkaempf@suse.de, ma@suse.de -->
<chapter>
<title>Requirements</title>

<section><title>2.1 General</title>

<para>
Handling package dependency resolving across multiple package sources
is quite complex. Since dependency resolving is performed online while
the user is viewing/selecting/deselcting packages, it must be reasonably
fast. This in turn requires memory.
</para>
<para>
Current dependency resolvers (SuSE YaST2, Caldera PHI) require a similar
amount of resources (ca 15 MB with YaST2 an 2500 package, ca 20 MB with
PHI and 3500 packages).
</para>
<para>
Dramatic improvements can only be achieved by reducing the number of
packages (and dependencies).
</para>
<para>
Combining a set of packages to a selection and then computing selection
dependencies is a possible solution. By handling selections similar
to packages (selections have a name, a version, and dependencies), the
same algorithms and similar user interfaces can be used.
Combining selections to distributions (which equal installation sources)
are a logical consequence.
</para>
<para>
This all leads to the following:
<itemizedlist>
<listitem><para>A set of bytes make a file
</para></listitem>
<listitem><para>A set of files make a package
</para></listitem>
<listitem><para>A set of packages make a selection
</para></listitem>
<listitem><para>A set of selections make a distribution
</para></listitem>
</itemizedlist>
[This leads to having selections as .rpm files and let rpm do all
the work in finding dependencies. However the selections are only
a package suggestion and rpms dependencies are too weak to handle
all cases. Having a selection database besides a package database
would be a good thing.]
</para>
</section>

<section><title>2.2 User Interface</title>

<para>
The package management must be usable by command line, by a text (curses)
interface, and by a graphical (X11) frontend.
Detailed functional requirements (use-cases) are listed below.
</para>

</section>
<section><title>2.3 Installation Media</title>

<para>
The concept of separated base and product CDs can be extended to a
variety of medias (CD, FTP, NFS, HTTP, ...) and contents (patch CD,
maintenance web server, network installation server, etc.)
</para>
<para>
Each media is named an <emphasis>Installation Source</emphasis>, since it's independant
from it's physical representation (CD, DVD, Network, ...).
</para>

<para>
Such an installation source must contain
<itemizedlist>
  <listitem><para>A media identifier
	To cleary (re-)identify a (known) medium
  </para></listitem>
  <listitem><para>A content description
	To show the user media information
  </para></listitem>
  <listitem><para>Further information (Vendor, Version, License, Architecture, ...)
	As a more detailed media description for the user.
  </para></listitem>
  <listitem><para>Selections
	As a means to reduce complexity as mentioned above.
  </para></listitem>
  <listitem><para>Packages
	The installable data.
  </para></listitem>
</itemizedlist>
</para>

<para> 
In addition to that, an installation source should contain:
</para>


<itemizedlist>
<listitem><para>
Package descriptions - technical data as well as textual descriptions for
all packages - as a cache for instant access to that information which
otherwise may be accessible only at a remote location with considerable access
times. 
</para></listitem>
</itemizedlist>


<para>
Integrating separate 'package sources' into the installer and doing
cross-media dependency resolving does have a lot of advantages:
<itemizedlist>
<listitem><para>Close interaction with SuSE installer
</para></listitem>
<listitem><para>Distributed installation (CD, DVD, NFS, ...)
</para></listitem>
<listitem><para>Abstracting from physical medium
</para></listitem>
<listitem><para>Overlaying package sources eases (online) updates or architecture
  specific packages (i.e. i686 optimized)
</para></listitem>
<listitem><para>an installation source might not be available (i.e. network
  server down)
</para></listitem>
<listitem><para>an installation source might be provided by a different
  vendor (not SuSE)
</para></listitem>
<listitem><para>an installation source might be unreliable (bad MD5)
</para></listitem>
<listitem><para>cost of accessing an  installation source
</para></listitem>
</itemizedlist>
</para>

<para>
If an installation media cannot be accessed, the user must have
the possibility of changing the media (i.e. ftp server, nfs path)
temporarely.
</para>

</section>
<section><title>2.4 Installation Target</title>

<para>
All package handling is always based on a single installation target,
the system being administered.
The target might be remote from the package management, esp. considering
embedded systems with limited resources for a full dependency handling.
</para>
<para>
Further requirements are:
<itemizedlist>
<listitem><para>Keep system consitent all the time.
</para></listitem>
<listitem><para>Install package from any source.
</para></listitem>
<listitem><para>Switch installation sources dynamically.
</para></listitem>
<listitem><para>Control RPM parameters (i.e. --oldpackage, --excludedocs)
</para></listitem>
</itemizedlist>
</para>

</section>
<section><title>2.5 Dependency Solving</title>

<para>
The current package handling is based on the package name only and does not
take the package version into account. This binds vendor packages 
to a specific distribution.
</para>
<para>
The multiple installation media concept introduces new solver
requirements since multiple sources can provide the same package (name)
with identical or different versions, dependencies, architectures.
This introduces a new level of complexity, as the package name
is no longer the only differentiating criterium for the solver.
Esp. dependencies (and conflicts) between different installation media
must be handled.
</para>
<para>
Having more detailed package dependencies opens up a new set of
packaging possibilities:
<itemizedlist>
<listitem><para>a package might be provided in several versions, user can choose
  'best' package (matching his application)
</para></listitem>
<listitem><para>easier up/downgrade of packages
</para></listitem>
<listitem><para>easier handling of patches (incl. removal of patches)
</para></listitem>
<listitem><para>Control dependency solving (i.e. switch it off)
</para></listitem>
</itemizedlist>
</para>

</section>
<section><title>2.6 Selections</title>

<para>
Selections are a means to reduce dependency complexity and to
group packages to functional blocks, thereby making it easier
to the customer to choose the right setup.
Selections are package list which contain including (to be added)
and excluding (to be removed) packages.
Selections also define dependencies (requirements, conflicts). By
adding version information also update complexity can be reduced.
</para>

</section>
<section><title>2.7 Packages</title>

<para>
A package is the smallest entity handled by the package management.
Packages consist of
<itemizedlist>
<listitem><para>A name
</para></listitem>
<listitem><para>A version
</para></listitem> 
<listitem><para>An architecture
</para></listitem> 
<listitem><para>Dependencies
</para></listitem>
<listitem><para>Files
</para></listitem>
<listitem><para>Attributes (Label, Size, Group Tag, ...)
</para></listitem> 
</itemizedlist>
</para>

<remark>see also ~sh/y2-proto/sw-single/sw-single-spec.txt </remark>

</section>
<section><title>2.8 Patches</title>

<para>
Patches describe changes to be made to a system.
A patch consists of
<itemizedlist>
<listitem><para>A name
</para></listitem>
<listitem><para>A version
</para></listitem> 
<listitem><para>An architecture
</para></listitem> 
<listitem><para>Dependencies
</para></listitem>
<listitem><para>Attributes
</para></listitem> 
<listitem><para>Text, Packages, Scripts
</para></listitem>
</itemizedlist>
</para>

</section>
<section><title>2.9 Update</title>

<para>
Things to consider for an update are:
<itemizedlist>
<listitem><para>A functionality (Requires-Tag) might be provided by several
packages. Decide which one to choose.
</para></listitem>
<listitem><para>Package renames
</para></listitem>
<listitem><para>Package splits
</para></listitem>
<listitem><para>Package drops
</para></listitem>
<listitem><para>Package unknown (foreign package) with dependencies
</para></listitem>
</itemizedlist>
</para>

</section>
</chapter>

